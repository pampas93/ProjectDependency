<!----------------------------------------------------------------------------
typetable.cpp Help file for Project #3
 Published 4 Apr 2017
 Abhijit Srikanth, CSE687 - Object Oriented Design, Spring 2017

 The below file is the webpage of the source code for typetable.cpp and holds links to its dependent files

 Note -Do not replace any markup characters with escape sequences
----------------------------------------------------------------------------->
<html>
<head>
<link rel = "stylesheet"type = "text/css"href = "../CodePublishHTML/myStyle.css" /></head>
<body class = "indent">
<script type="text/javascript" src="../CodePublishHTML/jquery-2.2.4.js"></script>
<script type="text/javascript" src="../CodePublishHTML/myJS.js"></script><h3>typetable.cpp</h3>
<hr><div class = "indent"><h4>Dependencies :</h4><ul><li> <a href="../CodePublishHTML/typetable.h.html">typetable.h</a> </li><li> <a href="../CodePublishHTML/ActionsAndRules.h.html">ActionsAndRules.h</a> </li><li> <a href="../CodePublishHTML/AbstrSynTree.h.html">AbstrSynTree.h</a> </li><li> <a href="../CodePublishHTML/FileSystem.h.html">FileSystem.h</a> </li>
</ul></div><hr>
<pre>
/////////////////////////////////////////////////////////////////////
//  typetable.cpp - Creates the Type Table				           //
//																   //
//  Language:      Visual C++ 2015                                 //
//  Platform:      Dell Inspiron, Windows 8.1			           //
//  Application:   Dependency Analysis - CIS 687 Project 2         //
//  Author:        Abhijit Srikanth SUID:864888072			       //
/////////////////////////////////////////////////////////////////////

#include "../TypeTable/typetable.h"

using namespace CodeAnalysis;

//&lt;------------------ TypeTable Class Constructor Building the AST tree ------------------&gt;
Type_Table::Type_Table() :
	ASTref_(Repository::getInstance()-&gt;AST()) {}

//&lt;------------------ Function to save into Unordered_map table ------------------&gt;
bool Type_Table::saveIntoTable(Key key, Value_Vector v)
<div class="header">-  {</div><div class="content">
	/*if (table.find(key) != table.end())
	return false;*/
	table[key] = v;
	return true;
</div>}

//&lt;------------------ Returns count of table ------------------&gt;
size_t Type_Table::count()
<div class="header">-  {</div><div class="content">
	return table.size();
</div>}

//&lt;------------------ Checks if token is of type Class, struct, enum or global func ------------------&gt;
bool Type_Table::isType(ASTNode*pNode)
<div class="header">-  {</div><div class="content">
	static std::string types[] = {
		"class", "struct", "enum"
	};
	
	if ((pNode-&gt;type_ == "function" || pNode-&gt;type_ == "class") && (!(pNode-&gt;startLineCount_ == pNode-&gt;endLineCount_) && !(pNode-&gt;startLineCount_+1 == pNode-&gt;endLineCount_)))
	{
		std::vector&lt;int&gt; tint(2);
		
		tint.at(0) = pNode-&gt;startLineCount_;
		tint.at(1) = pNode-&gt;endLineCount_;
		lineVector temp = lineMap[pNode-&gt;path_];
		temp.push_back(tint);
		lineMap[pNode-&gt;path_] = temp;
	}

	if (pNode-&gt;type_ == "function" && nameSpace == "Global Namespace" && pNode-&gt;name_ != "main" && pNode-&gt;name_ != "void" && parent_type == "namespace")
	{
		return true;
	}
	for (std::string type : types)
	{
		if (pNode-&gt;type_ == type)
			return true;
	}
	return false;
</div>}

//&lt;------------------ DFS traversal through AST Tree ------------------&gt;
void Type_Table::traversal(ASTNode* pNode)
<div class="header">-  {</div><div class="content">
	try
	{
		if (pNode-&gt;type_ == "namespace")
			namespaceStack.push(pNode-&gt;name_);
		nameSpace = namespaceStack.top();
		if (isType(pNode))
		{
			Values x;
			x.file_name = pNode-&gt;path_;
			x.nameSpace_name = nameSpace;
			x.node_type = pNode-&gt;type_;
			std::vector&lt;Values&gt; temp;
			if (table.find(pNode-&gt;name_) != table.end())
			{
				temp = table[pNode-&gt;name_];
				temp.push_back(x);
			}
			else {
				temp.push_back(x);
			}
			saveIntoTable(pNode-&gt;name_, temp);
		}
		for (auto pChild : pNode-&gt;children_)
		{

			parent_type = pNode-&gt;type_;
			traversal(pChild);
			parent_type = pNode-&gt;type_;
		}
		if (pNode-&gt;type_ == "namespace") {
			namespaceStack.pop();
		}
	}
	catch (const std::exception& e)
	{
		std::cout &lt;&lt; e.what();
	}
</div>}

//&lt;------------------ Populate the type table (main function to call) ------------------&gt;
void Type_Table::populateTypeTable()
<div class="header">-  {</div><div class="content">
	try
	{
		ASTNode* proot = ASTref_.root();
		traversal(proot);
		//displayMap();
	}
	catch (const std::exception& e)
	{
		std::cout &lt;&lt; e.what();
	}
</div>}

//&lt;------------------ Returns the keys from table ------------------&gt;
std::vector&lt;std::string&gt; Type_Table::keys()
<div class="header">-  {</div><div class="content">
	std::vector&lt;std::string&gt; temp;
	for (Item item : table)
	{
		temp.push_back(item.first);
	}
	return temp;
</div>}

//&lt;------------------ Returns the keys from table ------------------&gt;
/*void Type_Table::displayMap()
{
for (Item item : table)
{
std::cout &lt;&lt; "\n " &lt;&lt; item.first;
for (Values x : item.second)
std::cout &lt;&lt; "\n\t" &lt;&lt; x.file_name &lt;&lt; "\t" &lt;&lt; x.nameSpace_name &lt;&lt; "\t" &lt;&lt; x.node_type;
std::cout &lt;&lt; "\n ";
}
}*/

//&lt;------------------ Returns the typeTable back to main ------------------&gt;
std::unordered_map&lt;Key, std::vector&lt;Values&gt;&gt;& Type_Table::returnTypeTable()
<div class="header">-  {</div><div class="content">
	return table;
</div>}

std::unordered_map&lt;std::string, std::vector&lt;std::vector&lt;int&gt;&gt;&gt;& Type_Table::returnLineMap()
<div class="header">-  {</div><div class="content">
	return lineMap;
</div>}

#ifdef TEST_TestTable

int main()
<div class="header">-  {</div><div class="content">
	Type_Table tb_temp;
	tb_temp.populateTypeTable();

	using Value_Vector = std::vector&lt;Values&gt;;
	using Item = std::pair&lt;Key, Value_Vector&gt;;

	for (Item item : tb_temp.returnTypeTable())
	{
		std::cout &lt;&lt; "\n " &lt;&lt; item.first;
		for (Values x : item.second)
			std::cout &lt;&lt; "\n\t" &lt;&lt; x.file_name &lt;&lt; "\t" &lt;&lt; x.nameSpace_name &lt;&lt; "\t" &lt;&lt; x.node_type;
		std::cout &lt;&lt; "\n ";
	}

</div>}
#endif


</pre>
</body>
</html>