<!----------------------------------------------------------------------------
SCC.cpp Help file for Project #3
 Published 4 Apr 2017
 Abhijit Srikanth, CSE687 - Object Oriented Design, Spring 2017

 The below file is the webpage of the source code for SCC.cpp and holds links to its dependent files

 Note -Do not replace any markup characters with escape sequences
----------------------------------------------------------------------------->
<html>
<head>
<link rel = "stylesheet"type = "text/css"href = "../CodePublishHTML/myStyle.css" /></head>
<body class = "indent">
<script type="text/javascript" src="../CodePublishHTML/jquery-2.2.4.js"></script>
<script type="text/javascript" src="../CodePublishHTML/myJS.js"></script><h3>SCC.cpp</h3>
<hr><div class = "indent"><h4>Dependencies :</h4><ul><li> <a href="../CodePublishHTML/SCC.h.html">SCC.h</a> </li><li> <a href="../CodePublishHTML/DependencyAnalysis.h.html">DependencyAnalysis.h</a> </li><li> <a href="../CodePublishHTML/FileSystem.h.html">FileSystem.h</a> </li><li> <a href="../CodePublishHTML/typetable.h.html">typetable.h</a> </li>
</ul></div><hr>
<pre>
/////////////////////////////////////////////////////////////////////
//  SCC.cpp - Creates a Strongly Connected graph		           //
//																   //
//  Language:      Visual C++ 2015                                 //
//  Platform:      Dell Inspiron, Windows 8.1			           //
//  Application:   Dependency Analysis - CIS 687 Project 2         //
//  Author:        Abhijit Srikanth SUID:864888072			       //
/////////////////////////////////////////////////////////////////////

#include "../StrongComponents/SCC.h"

//---------------------------- Graph Class ------------------------------//

//&lt;---------------------- Default Constructor -------------------&gt;
Directed_Graph::Directed_Graph()
{
}

Directed_Graph::~Directed_Graph()
<div class="header">-  {</div><div class="content">
	delete[] adjacency_matrix;
</div>}

//&lt;---------------------- Main Graph function to create Adjacency Matrix and Map to tag int to paths -------------------&gt;
std::unordered_map&lt;std::string, int&gt; Directed_Graph::createGraph(DependencyTable &dptemp)
<div class="header">-  {</div><div class="content">
	try {
		dpx = dptemp;
		arrayOfFiles = dpx.getAllFiles();
		verticesCount = makeMap();
		adjacency_matrix = new std::list&lt;int&gt;[verticesCount];
		makeAdjMatrix();

		return file2IntMap;
	}
	catch (const std::exception& e)
	{
		std::cout &lt;&lt; e.what();
	}
	return file2IntMap;
</div>}

//&lt;---------------------- Constructing an unordered Map to map Each file path to int -------------------&gt;
int Directed_Graph::makeMap()
<div class="header">-  {</div><div class="content">
	int i = 0;
	for (File x : arrayOfFiles)
	{
		file2IntMap[x] = i;
		i++;
	}
	return i;
</div>}

//&lt;---------------------- Constructing an Adjacency Matrix -------------------&gt;
void Directed_Graph::makeAdjMatrix()
<div class="header">-  {</div><div class="content">
	//adjacency_matrix = new std::list&lt;int&gt;[verticesCount];
	depTable = dpx.getDb();
	
	Files files = depTable.keys();
	for (File file : files)
	{
		Files listFiles = depTable.value(file).dependencies.getValue();
		int index = file2IntMap[file];
		for (File x : listFiles)
		{
			adjacency_matrix[index].push_back(file2IntMap[x]);
		}
	}
</div>}

//&lt;---------------------- Returning the private Adjacency matrix -------------------&gt;
std::list&lt;int&gt;* Directed_Graph::returnAdjMat()
<div class="header">-  {</div><div class="content">
	return adjacency_matrix;
</div>}




//---------------------------- StronglyConnectedComps Class ------------------------------//

//&lt;---------------------- Default Constructor -------------------&gt;
StronglyConnectedComps::StronglyConnectedComps()
{
}

//&lt;---------------------- Main Function to create SCC -------------------&gt;
void StronglyConnectedComps::makeGraph(DependencyTable dp)
<div class="header">-  {</div><div class="content">
	dpTable = dp;
	file2 = graph.createGraph(dpTable);
	vertices_no = (int)file2.size();
	adj_matrix = graph.returnAdjMat();
	SCCMain();
	//SccDisplay();
</div>}

//&lt;---------------------- Strongly Connected Graph construction -------------------&gt;
void StronglyConnectedComps::SCCMain()
<div class="header">-  {</div><div class="content">
	try {
		int *vss = new int[vertices_no];
		int *scc_low = new int[vertices_no];
		bool *sBool = new bool[vertices_no];
		std::stack&lt;int&gt; *scc_stack = new std::stack&lt;int&gt;();

		for (int i = 0; i &lt; vertices_no; i++)
		{
			vss[i] = -1;
			scc_low[i] = -1;
			sBool[i] = false;
		}

		for (int i = 0; i &lt; vertices_no; i++)
			if (vss[i] == -1)
				SCC_Recursive(i, vss, scc_low, scc_stack, sBool);

		delete[] vss;
		delete[] scc_low;
		delete[] sBool;
		delete scc_stack;
	}
	catch (const std::exception& e)
	{
		std::cout &lt;&lt; e.what();
	}

</div>}

//&lt;---------------------- SCC Recursive function -------------------&gt;
void StronglyConnectedComps::SCC_Recursive(int u, int vss[], int scc_low[], std::stack&lt;int&gt;* scc_stack, bool sBool[])
<div class="header">-  {</div><div class="content">
	try {
		static int time = 0;

		vss[u] = scc_low[u] = ++time;
		scc_stack-&gt;push(u);
		sBool[u] = true;

		std::list&lt;int&gt;::iterator i;
		for (i = adj_matrix[u].begin(); i != adj_matrix[u].end(); ++i)
		{
			int v = *i;
			if (vss[v] == -1)
			{
				SCC_Recursive(v, vss, scc_low, scc_stack, sBool);
				scc_low[u] = min(scc_low[u], scc_low[v]);
			}

			else if (sBool[v] == true)
				scc_low[u] = min(scc_low[u], vss[v]);
		}

		int w = 0;
		if (scc_low[u] == vss[u])
		{
			while (scc_stack-&gt;top() != u)
			{
				w = (int)scc_stack-&gt;top();
				temp.push_back(valueInMap(w));
				//std::cout &lt;&lt; w &lt;&lt; " ";
				sBool[w] = false;
				scc_stack-&gt;pop();
			}
			w = (int)scc_stack-&gt;top();
			temp.push_back(valueInMap(w));
			scc_matrix[ijk] = temp;
			ijk++;
			temp.clear();
			//std::cout &lt;&lt; w &lt;&lt; "\n";
			sBool[w] = false;
			scc_stack-&gt;pop();
		}
	}
	catch (const std::exception& e)
	{
		std::cout &lt;&lt; e.what();
	}
</div>}

//&lt;---------------------- Mapping back from int back to file path -------------------&gt;
std::string StronglyConnectedComps::valueInMap(int w)
<div class="header">-  {</div><div class="content">
	for (auto i : file2)
	{
		if (i.second == w)
			return i.first;
	}
	return "Null";
</div>}

//&lt;---------------------- Returns the Strongly connected matrix -------------------&gt;
std::unordered_map&lt;int, std::vector&lt;std::string&gt;&gt;& StronglyConnectedComps::returnMatrix()
<div class="header">-  {</div><div class="content">
	return scc_matrix;
</div>}

//&lt;---------------------- Persisting Scc graph into XML -------------------&gt;
//std::string StronglyConnectedComps::persistXml(std::string path)
//{
//	std::string xml;
//	XmlDocument document;
//	sptr pRoot = makeTaggedElement("Strongly Connected Components");
//	document.docElement() = pRoot;
//	int i = 1;
//	for (auto x : scc_matrix)
//	{
//		sptr pKey = makeTaggedElement("SCC");
//		pRoot-&gt;addChild(pKey);
//		for (auto xx : x.second)
//		{
//			sptr px = makeTaggedElement("File");
//			pKey-&gt;addChild(px);
//			sptr pxkey = makeTextElement(xx);
//			px-&gt;addChild(pxkey);
//		}
//	}
//	xml = document.toString();
//	//std::string path = "../XML_SCC.xml";
//	try
//	{
//		std::ofstream sample(path);
//		sample &lt;&lt; xml;
//		sample.close();
//	}
//	catch (const std::exception& e)
//	{
//		std::cout &lt;&lt; e.what();
//	}
//	return xml;
//}

//void StronglyConnectedComps::SccDisplay()
//{
//	for (auto toD : scc_matrix)
//	{
//		for (auto xx : toD.second)
//		{
//			std::cout &lt;&lt; xx &lt;&lt; "\t";
//		}
//		std::cout &lt;&lt; "\n";
//	}
//}

#ifdef TEST_SCC

int main()
<div class="header">-  {</div><div class="content">

	using File = std::string;
	using Files = std::vector&lt;File&gt;;
	Files allfilePaths;

	allfilePaths.push_back("C:\\Users\\Abhijit\\Desktop\\Project2_OOD\\TestingPurpose\\TestingPurpose\\B.h");
	allfilePaths.push_back("C:\\Users\\Abhijit\\Desktop\\Project2_OOD\\TestingPurpose\\TestingPurpose\\A.h");
	allfilePaths.push_back("C:\\Users\\Abhijit\\Desktop\\Project2_OOD\\TestingPurpose\\TestingPurpose\\A.cpp");
	allfilePaths.push_back("C:\\Users\\Abhijit\\Desktop\\Project2_OOD\\TestingPurpose\\TestingPurpose\\B.cpp");

	Type_Table tb;
	tb.populateTypeTable();

	DependencyTable dp_temp(tb.returnTypeTable(), allfilePaths);
	dp_temp.dependencyMain();

	StronglyConnectedComps scc_temp;
	scc_temp.makeGraph(dp_temp);

	for (auto toD : scc_temp.returnMatrix())
	{
		for (auto xx : toD.second)
		{
			std::cout &lt;&lt; xx &lt;&lt; "\t";
		}
		std::cout &lt;&lt; "\n";
	}
	
</div>}

#endif


</pre>
</body>
</html>